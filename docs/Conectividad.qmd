---
title: "Conectividad"
author: "David Murillo"
format: html
editor: visual
---

# Cargar paquetes

[Makurhini: An R package for comprehensive analysis of landscape fragmentation and connectivity](https://doi.org/10.21203/rs.3.rs-6398746/v1)

```{r}
#library(devtools)
#library(remotes)
# install_github("connectscape/Makurhini", dependencies = TRUE)

library(Makurhini)
```

```{r}
library(terra)
library(sf)
library(gdistance)
```

[R Package gdistance: Distances and Routes on Geographical Grids](https://www.jstatsoft.org/article/view/v076i13)

```{r}
data("habitat_nodes", package = "Makurhini")
```

`MK_dPCIIC` calcula el índice dPC (delta Probability of Connectivity) o sus componentes (intra, flux, connector) para múltiples umbrales de distancia.

```{r}
PC_example <- MK_dPCIIC(nodes = habitat_nodes, 
                        attribute = NULL, 
                        distance =list(type = "centroid"),
                        parallel = NULL, 
                        metric = "PC", 
                        probability = 0.5, 
                        distance_thresholds = c(250, 1500, 3000, 10000))

plot(PC_example$d250["dPC"])
```

- dPC: Valor total de conectividad asociado a ese parche. Este valor representa cuánto contribuye el parche a la conectividad total del paisaje. Parches con valores altos son más importantes para mantener la conectividad general.

- dPCintra: Esta parte representa la conectividad interna, que depende del tamaño del parche. Si es igual al dPC, significa que el parche no está conectado a otros (o que la especie no puede moverse a otros parches dentro del umbral de distancia).

- dPCflux: Representa el flujo de conectividad directa con otros parches. Si este valor es 0, el parche no tiene conexiones directas dentro del umbral de dispersión.

- dPCconnector: Mide el valor del parche como puente entre otros. Un valor alto indica que el parche sirve como paso intermedio para conectar otros parches que de otra forma estarían aislados.

Example 3: Identifying the most important corridors to maintain and improve the connectivity of
forest mammals in northern Spain

```{r}
data("habitat_nodes_spain", package = "Makurhini")
data("dist_original", package = "Makurhini")

n_cores<-15
```


PCconnections <- MK_dPCIIC_links(nodes=habitat_nodes_spain,
                                 attribute="attribute", 
                                 area_unit ="ha", 
                                 distance=dist_original, 
                                 metric = "PC", 
                                 probability=0.5,
                                 distance_thresholds=980966.64, 
                                 parallel=n_cores, 
                                 parallel_mode=1, 
                                 removal=TRUE)



# Iconnect

```{r}
# library(devtools)
# install_github("FMestre1/lconnect")
library(lconnect)
```

[Iconnect](https://doi.org/10.1016/j.ecolmodel.2023.110489)

```{r}
#Load data
vec_path <- system.file("extdata/vec_projected.shp", package = "lconnect")
```

```{r}
#upload landscape
land <- upload_land(vec_path, habitat = 1, max_dist = 500)
class(land)

```

```{r}
plot(land, main="Landscape clusters")
```

```{r}
land1 <- patch_imp(land, metric="IIC")
```

```{r}
plot(land1, main="Patch prioritization (%)")
```

# Grainscape

[The r toolbox grainscape for modelling and visualizing landscape connectivity using spatially explicit networks](https://doi.org/10.1111/2041-210X.13350)

```{r}
library(grainscape)

tiny <- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost <- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG <- MPG(cost = tinyCost, patch = tinyCost == 1)
## Extract a representative subset of 5 grains of connectivity
tinyPatchGOC <- GOC(tinyPatchMPG, nThresh = 5)
## Quick visualization of a corridor
corridorStartEnd <- rbind(c(10, 10), c(90, 90))
tinyPatchCorridor <- corridor(tinyPatchGOC, whichThresh = 3, coords = corridorStartEnd)
if (interactive())
  plot(tinyPatchCorridor)

## More control over a corridor visualization
if (interactive()) {
  plot(tinyPatchCorridor@voronoi, col = "lightgrey", lwd = 2)
  plot(tinyPatchCorridor@linksSP, col = "darkred", lty = "dashed", add = TRUE)
  plot(tinyPatchCorridor@nodesSP, col = "darkred", pch = 21, bg = "white", add = TRUE)
  plot(tinyPatchCorridor@shortestLinksSP, col = "darkred", lty = "solid", lwd = 2, add = TRUE)
  plot(tinyPatchCorridor@shortestNodesSP, col = "darkred", pch = 21, bg = "darkred", add = TRUE)
  mtext(paste("Corridor shortest path length:",
              round(tinyPatchCorridor@corridorLength, 2),
              "resistance units"), side = 1)
}
```

# Conectividad genetica
